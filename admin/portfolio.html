<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; base-uri 'self'; object-src 'none'; form-action 'self'; img-src 'self' data: https: blob:; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; font-src 'self' https://cdnjs.cloudflare.com data:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.gstatic.com https://www.googleapis.com https://apis.google.com https://cdnjs.cloudflare.com; script-src-attr 'none'; connect-src 'self' https://firestore.googleapis.com https://firebasestorage.googleapis.com https://storage.googleapis.com https://*.googleapis.com https://*.firebaseio.com https://www.googleapis.com; frame-src 'self' https://*.firebaseapp.com https://*.google.com https://accounts.google.com; worker-src 'self' blob:;">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin - Manage Portfolio</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="icon" type="image/x-icon" href="../image/Headshot.jpg">
  <style>
    body { background: linear-gradient(135deg, #020212 0%, #0f0a1a 100%); color: #f0f0f0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; min-height: 100vh; }
    header { background: linear-gradient(135deg, #1B16A8 0%, #020212 100%); padding: 20px 0; border-bottom: 1px solid rgba(124,58,237,0.2); position: sticky; top: 0; z-index: 100; }
    .header-content { max-width: 1200px; margin: 0 auto; padding: 0 20px; display: flex; justify-content: space-between; align-items: center; }
    .logo { font-size: 1.6rem; font-weight: 800; background: linear-gradient(135deg, #1B16A8, #7C3AED); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .header-actions { display: flex; gap: 12px; align-items: center; }
    .logout-btn, .back-btn { padding: 8px 16px; border-radius: 8px; border: 2px solid #7C3AED; background: transparent; color: #7C3AED; cursor: pointer; font-weight: 600; font-size: 0.85rem; }
    .logout-btn:hover, .back-btn:hover { background: rgba(124,58,237,0.1); }
    .container { max-width: 1200px; margin: 0 auto; padding: 32px 20px 60px; }
    .grid { display: grid; grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr); gap: 28px; align-items: flex-start; }
    .section { background: radial-gradient(circle at top left, rgba(124,58,237,0.2), transparent 55%), linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid rgba(124,58,237,0.25); border-radius: 18px; padding: 24px 22px; box-shadow: 0 18px 45px rgba(0,0,0,0.45); }
    .section h2 { font-size: 1.4rem; margin-bottom: 16px; color: #7C3AED; display: flex; align-items: center; gap: 10px; }
    .upload-area { border: 3px dashed #7C3AED; border-radius: 14px; padding: 40px 20px; text-align: center; cursor: pointer; background: rgba(124,58,237,0.05); margin-bottom: 18px; }
    .upload-area i { font-size: 3rem; color: #7C3AED; margin-bottom: 12px; display: block; }
    .upload-area p { color: #bbb; margin-bottom: 6px; font-size: 0.95rem; }
    .upload-area .highlight { color: #7C3AED; font-weight: 700; }
    input[type="file"] { display: none; }
    .form-group { margin-bottom: 16px; }
    .form-group label { display: block; margin-bottom: 6px; color: #bbb; font-weight: 600; font-size: 0.9rem; }
    .form-group input, .form-group textarea, .form-group select { width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid rgba(124,58,237,0.3); background: rgba(255,255,255,0.05); color: #f0f0f0; font-size: 0.9rem; }
    .form-group textarea { min-height: 70px; resize: vertical; }
    .preview-image { width: 100%; height: 220px; object-fit: cover; border-radius: 10px; margin-bottom: 12px; border: 1px solid rgba(124,58,237,0.2); display: none; }
    .file-info { font-size: 0.8rem; color: #aaa; margin-bottom: 12px; }
    .inline-check { display: flex; align-items: center; gap: 10px; color: #bbb; font-weight: 600; font-size: 0.9rem; }
    .inline-check input { width: auto; }
    .existing-images { display: flex; gap: 10px; padding: 10px; border-radius: 12px; border: 1px solid rgba(124,58,237,0.25); background: rgba(0,0,0,0.12); overflow-x: auto; }
    .existing-image { position: relative; width: 96px; height: 72px; border-radius: 10px; overflow: hidden; border: 2px solid rgba(124,58,237,0.25); background: #0b0b12; flex: 0 0 auto; }
    .existing-image img { width: 100%; height: 100%; object-fit: cover; display: block; filter: brightness(0.92); }
    .existing-image.removed { opacity: 0.45; border-color: rgba(244, 67, 54, 0.65); }
    .existing-image button { position: absolute; top: 6px; right: 6px; width: 24px; height: 24px; border-radius: 8px; border: none; cursor: pointer; font-weight: 900; color: #fff; background: rgba(244, 67, 54, 0.9); }
    .existing-image.removed button { background: rgba(76, 175, 80, 0.85); }
    .button-group { display: flex; gap: 10px; margin-top: 10px; }
    .btn { flex: 1; padding: 11px; border-radius: 8px; border: none; cursor: pointer; font-weight: 600; font-size: 0.9rem; }
    .btn-upload { background: linear-gradient(135deg, #1B16A8, #7C3AED); color: #fff; }
    .btn-clear { background: transparent; border: 2px solid #7C3AED; color: #7C3AED; }
    .photo-grid { display: grid; grid-template-columns: 1fr; gap: 12px; max-height: 640px; overflow-y: auto; }
    .photo-item { background: rgba(27,22,168,0.15); border: 1px solid rgba(124,58,237,0.25); border-radius: 12px; padding: 10px 12px; display: flex; gap: 10px; align-items: center; }
    .photo-thumbnail { width: 76px; height: 76px; object-fit: cover; border-radius: 8px; border: 1px solid rgba(124,58,237,0.2); }
    .photo-info { flex: 1; min-width: 0; }
    .photo-info h4 { margin: 0 0 4px 0; font-size: 0.95rem; }
    .photo-info p { margin: 0 0 3px 0; font-size: 0.8rem; color: #a6a6b3; }
    .photo-stats { display: flex; gap: 12px; font-size: 0.78rem; color: #7C3AED; }
    .photo-actions { display: flex; gap: 8px; }
    .btn-edit, .btn-delete { padding: 7px 12px; border-radius: 6px; font-size: 0.8rem; font-weight: 600; cursor: pointer; border: none; }
    .btn-edit { background: transparent; border: 2px solid #7C3AED; color: #7C3AED; }
    .btn-delete { background: #e74c3c; color: #fff; }
    .message { padding: 12px; border-radius: 10px; margin-bottom: 14px; display: none; font-weight: 600; }
    .message.show { display: block; }
    .message.success { background: rgba(76,175,80,0.2); border: 1px solid #4caf50; color: #81c784; }
    .message.error { background: rgba(244,67,54,0.2); border: 1px solid #f44336; color: #ef5350; }
    .empty-state { text-align: center; padding: 32px 10px; color: #666; }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <div class="logo"><i class="fas fa-images"></i> Manage Portfolio</div>
      <div class="header-actions">
        <button class="back-btn" id="backBtn" type="button">&larr; Back to Dashboard</button>
        <button class="logout-btn" id="logoutBtn" type="button">Logout</button>
      </div>
    </div>
  </header>

  <div class="container">
    <div id="successMessage" class="message success"></div>
    <div id="errorMessage" class="message error"></div>

    <div class="grid">
      <div class="section">
        <h2><i class="fas fa-cloud-upload-alt"></i> Upload / Edit Photo</h2>
        <div class="upload-area" id="uploadArea">
          <i class="fas fa-image"></i>
          <p>Drag and drop up to <span class="highlight">10 images</span> here</p>
          <p>or <span class="highlight">click to browse</span></p>
        </div>
        <input type="file" id="fileInput" multiple accept="image/*,.heic,.HEIC,.dng,.DNG,.cr2,.CR2,.nef,.NEF,.arw,.ARW,.tif,.tiff,.TIF,.TIFF">
        <div id="selectedImagesPreview" class="existing-images" style="display:none;"></div>
        <div id="fileInfo" class="file-info"></div>

        <div id="existingImagesSection" style="display:none;">
          <div class="form-group">
            <label>Current Images</label>
            <div id="existingImagesList" class="existing-images"></div>
            <div id="existingImagesInfo" class="file-info"></div>
          </div>
          <div class="form-group">
            <label class="inline-check">
              <input type="checkbox" id="replaceImagesCheckbox">
              Replace existing images (instead of adding)
            </label>
          </div>
        </div>

        <form id="uploadForm">
          <div class="form-group">
            <label for="photoTitle">Photo Title *</label>
            <input type="text" id="photoTitle" required>
          </div>
          <div class="form-group">
            <label for="photoDescription">Description</label>
            <textarea id="photoDescription"></textarea>
          </div>
          <div class="form-group">
            <label for="photoCategory">Category *</label>
            <select id="photoCategory" required>
              <option value="">Select a category</option>
              <option value="Portrait Photography">Portrait Photography</option>
              <option value="Cinematography">Cinematography</option>
              <option value="Architecture">Architecture</option>
              <option value="Nature">Nature</option>
              <option value="Events">Events</option>
              <option value="Other">Other</option>
            </select>
          </div>
          <div class="button-group">
            <button type="submit" class="btn btn-upload" id="submitBtn"><i class="fas fa-upload"></i> Upload Photo</button>
            <button type="button" class="btn btn-clear" id="clearBtn">Clear</button>
          </div>
        </form>
      </div>

      <div class="section">
        <h2><i class="fas fa-images"></i> Your Photos (<span id="photoCount">0</span>)</h2>
        <div class="photo-grid" id="photoList">
          <div class="empty-state">
            <i class="fas fa-inbox"></i>
            <p>No photos uploaded yet</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-storage-compat.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/heic2any/0.0.4/heic2any.min.js"></script>
  <script src="../assets/js/firebase-config.js"></script>
  <script src="../assets/js/firebase-init-compat.js"></script>
  <script>
    const auth = firebase.auth();
    const db = firebase.firestore();
    const storage = firebase.storage();
    const ADMIN_UID = "RVAvU26oGeYsaJYk0X1OF9h6apb2";
    let selectedFiles = [];
    let editingPhotoId = null;
    let existingImageUrls = [];
    let existingThumbUrls = [];
    let removedImageUrls = new Set();
    let replaceImages = false;
    let selectedPreviewObjectUrls = [];
    let selectedPreviewRenderToken = 0;

    function clearElement(el) {
      if (!el) return;
      while (el.firstChild) el.removeChild(el.firstChild);
    }

    function renderEmptyState(containerEl) {
      if (!containerEl) return;
      clearElement(containerEl);
      const wrap = document.createElement('div');
      wrap.className = 'empty-state';
      const icon = document.createElement('i');
      icon.className = 'fas fa-inbox';
      const p = document.createElement('p');
      p.textContent = 'No photos uploaded yet';
      wrap.appendChild(icon);
      wrap.appendChild(p);
      containerEl.appendChild(wrap);
    }

    function normalizeHttpUrl(url) {
      if (typeof url !== 'string') return null;
      try {
        const parsed = new URL(url, window.location.href);
        if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') return null;
        return parsed.href;
      } catch {
        return null;
      }
    }

    function clearSelectedPreviewObjectUrls() {
      if (!Array.isArray(selectedPreviewObjectUrls)) {
        selectedPreviewObjectUrls = [];
        return;
      }
      for (const u of selectedPreviewObjectUrls) {
        try { URL.revokeObjectURL(u); } catch {}
      }
      selectedPreviewObjectUrls = [];
    }

    function getFileExt(name) {
      if (typeof name !== 'string') return '';
      const idx = name.lastIndexOf('.');
      if (idx === -1) return '';
      return name.slice(idx + 1).toLowerCase();
    }

    function isHeicLike(file) {
      if (!file) return false;
      const t = (file.type || '').toLowerCase();
      if (t === 'image/heic' || t === 'image/heif') return true;
      const ext = getFileExt(file.name);
      return ext === 'heic' || ext === 'heif';
    }

    function isRawLike(file) {
      const ext = getFileExt(file && file.name);
      return ext === 'dng' || ext === 'cr2' || ext === 'nef' || ext === 'arw';
    }

    function formatBytes(bytes) {
      const n = Number(bytes);
      if (!Number.isFinite(n) || n <= 0) return '0 B';
      const units = ['B', 'KB', 'MB', 'GB'];
      const i = Math.min(units.length - 1, Math.floor(Math.log(n) / Math.log(1024)));
      const val = n / Math.pow(1024, i);
      return `${val.toFixed(val >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
    }

    function supportsCanvasWebpEncode() {
      try {
        const c = document.createElement('canvas');
        if (!c || typeof c.toDataURL !== 'function') return false;
        const data = c.toDataURL('image/webp');
        return typeof data === 'string' && data.startsWith('data:image/webp');
      } catch {
        return false;
      }
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise((resolve, reject) => {
        try {
          canvas.toBlob((b) => {
            if (!b) reject(new Error('toBlob-failed'));
            else resolve(b);
          }, type, quality);
        } catch (e) {
          reject(e);
        }
      });
    }

    async function loadImageFromBlob(blob) {
      const url = URL.createObjectURL(blob);
      try {
        const img = new Image();
        img.decoding = 'async';
        const p = new Promise((resolve, reject) => {
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error('image-decode-failed'));
        });
        img.src = url;
        return await p;
      } finally {
        try { URL.revokeObjectURL(url); } catch {}
      }
    }

    async function optimizeImageForUpload(inputFile) {
      // Goal: keep Storage costs low by resizing + compressing before upload.
      // Full-size (mobile-first): max 1440px, ~450KB target
      const MAX_DIM = 1440;
      const TARGET_BYTES = 450 * 1024;
      const HARD_CAP_BYTES = 1.2 * 1024 * 1024;
      const MIN_QUALITY = 0.5;
      const START_QUALITY = 0.8;

      if (!inputFile) throw new Error('missing-file');
      if (isRawLike(inputFile)) throw new Error('raw-not-supported');

      const mime = (inputFile.type || '').toLowerCase();
      const ext = getFileExt(inputFile.name);
      const isGif = mime === 'image/gif' || ext === 'gif';
      if (isGif) {
        if (inputFile.size > HARD_CAP_BYTES) throw new Error('file-too-large');
        return inputFile;
      }

      let sourceBlob = inputFile;

      if (isHeicLike(inputFile)) {
        const converter = await waitForHeic2any(2000);
        if (!converter) throw new Error('heic-convert-unavailable');
        sourceBlob = await converter({ blob: inputFile, toType: 'image/jpeg', quality: 0.92 });
      }

      // If already small enough and not enormous dimensions, keep original.
      if (sourceBlob.size <= TARGET_BYTES && sourceBlob.size <= HARD_CAP_BYTES) {
        return (sourceBlob instanceof File) ? sourceBlob : new File([sourceBlob], inputFile.name || 'image.jpg', { type: sourceBlob.type || 'image/jpeg', lastModified: Date.now() });
      }

      const img = await loadImageFromBlob(sourceBlob);
      const w = Number(img.naturalWidth) || Number(img.width) || 0;
      const h = Number(img.naturalHeight) || Number(img.height) || 0;
      if (!w || !h) throw new Error('bad-image-dimensions');

      const maxSide = Math.max(w, h);
      const scale = maxSide > MAX_DIM ? (MAX_DIM / maxSide) : 1;
      const outW = Math.max(1, Math.round(w * scale));
      const outH = Math.max(1, Math.round(h * scale));

      const canvas = document.createElement('canvas');
      canvas.width = outW;
      canvas.height = outH;
      const ctx = canvas.getContext('2d', { alpha: false });
      if (!ctx) throw new Error('no-canvas-context');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, 0, 0, outW, outH);

      const useWebp = supportsCanvasWebpEncode();
      const outType = useWebp ? 'image/webp' : 'image/jpeg';

      let quality = START_QUALITY;
      let blob = await canvasToBlob(canvas, outType, quality);

      // Iteratively reduce quality to hit target bytes.
      while (blob.size > TARGET_BYTES && quality > MIN_QUALITY) {
        quality = Math.max(MIN_QUALITY, quality - 0.08);
        blob = await canvasToBlob(canvas, outType, quality);
      }

      // If still too big, shrink dimensions a bit and try again.
      let shrinkPasses = 0;
      while (blob.size > TARGET_BYTES && blob.size > HARD_CAP_BYTES && shrinkPasses < 3) {
        shrinkPasses += 1;
        const nextW = Math.max(1, Math.round(canvas.width * 0.85));
        const nextH = Math.max(1, Math.round(canvas.height * 0.85));
        const c2 = document.createElement('canvas');
        c2.width = nextW;
        c2.height = nextH;
        const ctx2 = c2.getContext('2d', { alpha: false });
        if (!ctx2) break;
        ctx2.imageSmoothingEnabled = true;
        ctx2.imageSmoothingQuality = 'high';
        ctx2.drawImage(canvas, 0, 0, nextW, nextH);
        blob = await canvasToBlob(c2, outType, Math.max(MIN_QUALITY, quality));
      }

      if (blob.size > HARD_CAP_BYTES) throw new Error('file-too-large');

      const baseName = (inputFile.name || 'image').replace(/\.[^.]+$/, '');
      const outExt = outType === 'image/webp' ? 'webp' : 'jpg';
      const outName = `${baseName}.${outExt}`;
      return new File([blob], outName, { type: outType, lastModified: Date.now() });
    }

    async function optimizeThumbnailForUpload(inputFile) {
      // Thumbnail for grid + modal strip: tiny + fast.
      // Slightly larger + higher quality to avoid ‚Äúblurry grid‚Äù previews,
      // while still staying cheap in Storage/bandwidth.
      const MAX_DIM = 768;
      const TARGET_BYTES = 140 * 1024;
      const HARD_CAP_BYTES = 260 * 1024;
      const MIN_QUALITY = 0.6;
      const START_QUALITY = 0.86;

      if (!inputFile) throw new Error('missing-file');
      if (isRawLike(inputFile)) throw new Error('raw-not-supported');

      const mime = (inputFile.type || '').toLowerCase();
      const ext = getFileExt(inputFile.name);
      const isGif = mime === 'image/gif' || ext === 'gif';
      if (isGif) {
        if (inputFile.size > HARD_CAP_BYTES) throw new Error('file-too-large');
        return inputFile;
      }

      let sourceBlob = inputFile;
      if (isHeicLike(inputFile)) {
        const converter = await waitForHeic2any(2000);
        if (!converter) throw new Error('heic-convert-unavailable');
        sourceBlob = await converter({ blob: inputFile, toType: 'image/jpeg', quality: 0.92 });
      }

      const img = await loadImageFromBlob(sourceBlob);
      const w = Number(img.naturalWidth) || Number(img.width) || 0;
      const h = Number(img.naturalHeight) || Number(img.height) || 0;
      if (!w || !h) throw new Error('bad-image-dimensions');

      const maxSide = Math.max(w, h);
      const scale = maxSide > MAX_DIM ? (MAX_DIM / maxSide) : 1;
      const outW = Math.max(1, Math.round(w * scale));
      const outH = Math.max(1, Math.round(h * scale));

      const canvas = document.createElement('canvas');
      canvas.width = outW;
      canvas.height = outH;
      const ctx = canvas.getContext('2d', { alpha: false });
      if (!ctx) throw new Error('no-canvas-context');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, 0, 0, outW, outH);

      const useWebp = supportsCanvasWebpEncode();
      const outType = useWebp ? 'image/webp' : 'image/jpeg';

      let quality = START_QUALITY;
      let blob = await canvasToBlob(canvas, outType, quality);
      while (blob.size > TARGET_BYTES && quality > MIN_QUALITY) {
        quality = Math.max(MIN_QUALITY, quality - 0.06);
        blob = await canvasToBlob(canvas, outType, quality);
      }

      if (blob.size > HARD_CAP_BYTES) throw new Error('file-too-large');

      const baseName = (inputFile.name || 'thumb').replace(/\.[^.]+$/, '');
      const outExt = outType === 'image/webp' ? 'webp' : 'jpg';
      const outName = `${baseName}_thumb.${outExt}`;
      return new File([blob], outName, { type: outType, lastModified: Date.now() });
    }

    async function waitForHeic2any(maxMs = 1200) {
      const start = Date.now();
      while (Date.now() - start < maxMs) {
        const candidate = window.heic2any;
        const fn = (typeof candidate === 'function')
          ? candidate
          : (candidate && typeof candidate.default === 'function' ? candidate.default : null);
        if (fn) return fn;
        await new Promise((r) => setTimeout(r, 80));
      }
      return null;
    }

    function renderUnpreviewableTile(container, label) {
      const tile = document.createElement('div');
      tile.className = 'existing-image removed';
      tile.style.display = 'flex';
      tile.style.alignItems = 'center';
      tile.style.justifyContent = 'center';
      tile.style.padding = '8px';
      tile.style.textAlign = 'center';
      tile.style.color = '#ddd';
      tile.style.fontSize = '0.7rem';
      tile.textContent = label || 'Preview not available';
      container.appendChild(tile);
    }

    async function loadPreviewIntoImg(file, imgEl, token) {
      if (!file || !imgEl) return;
      try {
        // RAW formats generally can't be previewed in-browser.
        if (isRawLike(file)) throw new Error('raw-not-previewable');

        let blobForPreview = file;
        if (isHeicLike(file)) {
          const converter = await waitForHeic2any(1200);
          if (converter) {
            blobForPreview = await converter({ blob: file, toType: 'image/jpeg', quality: 0.9 });
          } else {
            // Some browsers (notably Safari) can preview HEIC directly.
            // Fall back to trying the raw File object.
            blobForPreview = file;
          }
        }

        const url = URL.createObjectURL(blobForPreview);
        if (token !== selectedPreviewRenderToken) {
          try { URL.revokeObjectURL(url); } catch {}
          return;
        }
        selectedPreviewObjectUrls.push(url);
        imgEl.src = url;
      } catch (e) {
        // Let caller handle fallback.
        throw e;
      }
    }

    function renderSelectedImagesPreview() {
      const wrap = document.getElementById('selectedImagesPreview');
      if (!wrap) return;
      const files = Array.isArray(selectedFiles) ? selectedFiles.filter(Boolean) : [];

      selectedPreviewRenderToken += 1;
      const token = selectedPreviewRenderToken;
      clearSelectedPreviewObjectUrls();
      clearElement(wrap);

      if (files.length === 0) {
        wrap.style.display = 'none';
        return;
      }

      wrap.style.display = '';
      files.forEach((file, idx) => {
        const card = document.createElement('div');
        card.className = 'existing-image';

        const img = document.createElement('img');
        img.alt = '';
        img.loading = 'lazy';
        img.src = '';
        img.style.background = '#0b0b12';
        img.onerror = () => {
          // Safari can sometimes fail decoding HEIC from object URLs.
          // Try a data URL fallback before giving up.
          try {
            if (!file || token !== selectedPreviewRenderToken) throw new Error('stale');
            const reader = new FileReader();
            reader.onload = () => {
              if (token !== selectedPreviewRenderToken) return;
              if (typeof reader.result === 'string') img.src = reader.result;
            };
            reader.onerror = () => {
              if (token !== selectedPreviewRenderToken) return;
              if (card && card.parentNode) {
                const ext = getFileExt(file && file.name);
                card.innerHTML = '';
                card.className = 'existing-image removed';
                const label = document.createElement('div');
                label.style.padding = '8px';
                label.style.fontSize = '0.7rem';
                label.style.textAlign = 'center';
                label.style.color = '#ddd';
                label.textContent = ext ? `${ext.toUpperCase()} preview not supported` : 'Preview not supported';
                card.appendChild(label);
              }
            };
            reader.readAsDataURL(file);
          } catch {
            // ignore
          }
        };
        card.appendChild(img);

        // Load preview (with HEIC conversion when possible).
        loadPreviewIntoImg(file, img, token).catch((err) => {
          const ext = getFileExt(file && file.name);
          if (String(err && err.message) === 'raw-not-previewable') {
            card.innerHTML = '';
            renderUnpreviewableTile(card, ext ? `${ext.toUpperCase()} can't preview` : `Can't preview`);
            return;
          }
          // Otherwise, let the onerror handler handle it if needed.
        });

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.title = 'Remove from selection';
        btn.textContent = '√ó';
        btn.addEventListener('click', () => {
          selectedFiles = files.filter((_, i) => i !== idx);
          reconcileSelectionLimit();
          renderSelectedImagesPreview();
          updateFileInfoText();
        });
        card.appendChild(btn);

        wrap.appendChild(card);
      });
    }

    function updateFileInfoText() {
      const info = document.getElementById('fileInfo');
      if (!info) return;

      if (!selectedFiles || selectedFiles.length === 0) {
        info.textContent = '';
        return;
      }

      const files = selectedFiles.filter(Boolean);
      if (files.length === 1) {
        const file = files[0];
        const sizeMb = (file.size / (1024 * 1024)).toFixed(2);
        info.textContent = editingPhotoId
          ? `Selected new image: ${file.name} (${sizeMb} MB)${replaceImages ? ' (will replace existing images)' : ' (will be added)'} ‚Äî uploads are auto-optimized`
          : `Selected: ${file.name} (${sizeMb} MB) ‚Äî uploads are auto-optimized`;
      } else {
        const totalMb = (files.reduce((sum, f) => sum + (f ? f.size : 0), 0) / (1024 * 1024)).toFixed(2);
        info.textContent = editingPhotoId
          ? `Selected new images: ${files.length} (${totalMb} MB total)${replaceImages ? ' (will replace existing images)' : ' (will be added)'} ‚Äî uploads are auto-optimized`
          : `Selected: ${files.length} images (${totalMb} MB total) ‚Äî uploads are auto-optimized`;
      }
    }

    function mergeSelectedFiles(existing, incoming, maxCount) {
      const safeExisting = Array.isArray(existing) ? existing.filter(Boolean) : [];
      const safeIncoming = Array.isArray(incoming) ? incoming.filter(Boolean) : [];

      const seen = new Set();
      const out = [];
      const keyFor = (f) => `${f && f.name ? f.name : ''}::${f && f.size ? f.size : 0}::${f && f.lastModified ? f.lastModified : 0}`;

      for (const f of safeExisting) {
        const k = keyFor(f);
        if (seen.has(k)) continue;
        seen.add(k);
        out.push(f);
        if (out.length >= maxCount) return out;
      }

      for (const f of safeIncoming) {
        const k = keyFor(f);
        if (seen.has(k)) continue;
        seen.add(k);
        out.push(f);
        if (out.length >= maxCount) return out;
      }

      return out;
    }

    function getPrevUrlsFromDoc(photo) {
      const urls = Array.isArray(photo && photo.imageUrls)
        ? photo.imageUrls
        : (photo && photo.imageUrl ? [photo.imageUrl] : []);
      return urls.map((u) => normalizeHttpUrl(u)).filter(Boolean).slice(0, 10);
    }

    function getPrevThumbUrlsFromDoc(photo) {
      const urls = Array.isArray(photo && photo.thumbUrls)
        ? photo.thumbUrls
        : (photo && photo.thumbUrl ? [photo.thumbUrl] : []);
      return urls.map((u) => normalizeHttpUrl(u)).filter(Boolean).slice(0, 10);
    }

    function alignThumbsToFull(fullUrls, thumbUrls) {
      const full = Array.isArray(fullUrls) ? fullUrls.filter(Boolean).slice(0, 10) : [];
      const thumbs = Array.isArray(thumbUrls) ? thumbUrls.filter(Boolean).slice(0, 10) : [];
      if (thumbs.length >= full.length) return thumbs.slice(0, full.length);
      const out = thumbs.slice();
      for (let i = out.length; i < full.length; i++) out.push(full[i]);
      return out;
    }

    function mapFullToThumb(fullUrls, thumbUrls) {
      const full = Array.isArray(fullUrls) ? fullUrls : [];
      const thumbs = alignThumbsToFull(fullUrls, thumbUrls);
      const map = new Map();
      for (let i = 0; i < full.length; i++) {
        const f = full[i];
        const t = thumbs[i] || f;
        if (f && !map.has(f)) map.set(f, t);
      }
      return map;
    }

    function getKeptExistingUrls() {
      const list = Array.isArray(existingImageUrls) ? existingImageUrls : [];
      if (replaceImages) return [];
      return list.filter((u) => u && !removedImageUrls.has(u)).slice(0, 10);
    }

    function renderExistingImages() {
      const section = document.getElementById('existingImagesSection');
      const listEl = document.getElementById('existingImagesList');
      const infoEl = document.getElementById('existingImagesInfo');
      const checkbox = document.getElementById('replaceImagesCheckbox');
      if (!section || !listEl || !infoEl) return;

      const urls = Array.isArray(existingImageUrls) ? existingImageUrls : [];
      const thumbs = alignThumbsToFull(urls, existingThumbUrls);
      if (!editingPhotoId) {
        section.style.display = 'none';
        return;
      }

      section.style.display = '';
      if (checkbox) checkbox.checked = !!replaceImages;

      clearElement(listEl);
      if (urls.length === 0) {
        const empty = document.createElement('div');
        empty.style.color = '#888';
        empty.style.fontSize = '0.85rem';
        empty.textContent = 'No images saved for this project yet.';
        listEl.appendChild(empty);
      } else {
        urls.forEach((url, idx) => {
          const wrap = document.createElement('div');
          wrap.className = 'existing-image' + (removedImageUrls.has(url) || replaceImages ? ' removed' : '');

          const img = document.createElement('img');
          img.alt = '';
          img.loading = 'lazy';
          img.src = thumbs[idx] || url;
          wrap.appendChild(img);

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.title = removedImageUrls.has(url) ? 'Undo remove' : 'Remove image';
          btn.textContent = removedImageUrls.has(url) || replaceImages ? '‚Ü∫' : '√ó';
          btn.addEventListener('click', () => {
            if (replaceImages) {
              // In replace mode, existing images are treated as removed.
              return;
            }
            if (removedImageUrls.has(url)) removedImageUrls.delete(url);
            else removedImageUrls.add(url);
            renderExistingImages();
            reconcileSelectionLimit();
          });
          wrap.appendChild(btn);

          listEl.appendChild(wrap);
        });
      }

      const kept = getKeptExistingUrls().length;
      const removed = urls.filter((u) => removedImageUrls.has(u)).length;
      const mode = replaceImages ? 'Replace mode: existing images will be replaced on save.' : 'Add mode: selected images will be appended on save.';
      const remainingSlots = replaceImages ? 10 : Math.max(0, 10 - kept);
      infoEl.textContent = `${mode} Current: ${urls.length}. Keeping: ${kept}. Removed: ${replaceImages ? urls.length : removed}. You can add up to ${remainingSlots} more.`;
    }

    function reconcileSelectionLimit() {
      const info = document.getElementById('fileInfo');
      const incoming = Array.isArray(selectedFiles) ? selectedFiles.filter(Boolean) : [];
      const existingCount = getKeptExistingUrls().length;
      const allowed = replaceImages ? 10 : Math.max(0, 10 - existingCount);
      if (editingPhotoId && allowed <= 0) {
        selectedFiles = [];
        if (info) info.textContent = 'You already have 10 images. Remove one to add another.';
        return;
      }
      if (incoming.length > allowed) {
        selectedFiles = incoming.slice(0, allowed);
        showMessage('errorMessage', `‚ùå Max 10 images per project. Only ${allowed} new image${allowed === 1 ? '' : 's'} can be added right now.`);
      }
    }

    function createPhotoItem(docId, photo, createdAtLabel) {
      const item = document.createElement('div');
      item.className = 'photo-item';

      const img = document.createElement('img');
      img.className = 'photo-thumbnail';
      img.alt = (photo && typeof photo.title === 'string' && photo.title.trim()) ? photo.title : 'Portfolio photo';
      const images = Array.isArray(photo && photo.imageUrls)
        ? photo.imageUrls
        : (photo && photo.imageUrl ? [photo.imageUrl] : []);
      const thumbs = Array.isArray(photo && photo.thumbUrls)
        ? photo.thumbUrls
        : (photo && photo.thumbUrl ? [photo.thumbUrl] : []);
      const normalizedThumbUrl = normalizeHttpUrl(thumbs[0]);
      const normalizedImageUrl = normalizeHttpUrl(images[0]);
      if (normalizedThumbUrl) img.src = normalizedThumbUrl;
      else if (normalizedImageUrl) img.src = normalizedImageUrl;
      item.appendChild(img);

      const info = document.createElement('div');
      info.className = 'photo-info';

      const h4 = document.createElement('h4');
      h4.textContent = (photo && typeof photo.title === 'string' && photo.title.trim()) ? photo.title : 'Untitled';
      info.appendChild(h4);

      const cat = document.createElement('p');
      const strong = document.createElement('strong');
      strong.textContent = (photo && typeof photo.category === 'string' && photo.category.trim()) ? photo.category : 'Uncategorized';
      cat.appendChild(strong);
      info.appendChild(cat);

      const desc = document.createElement('p');
      desc.textContent = (photo && typeof photo.description === 'string' && photo.description.trim()) ? photo.description : 'No description';
      info.appendChild(desc);

      const stats = document.createElement('div');
      stats.className = 'photo-stats';
      const likes = document.createElement('span');
      const likeCount = (photo && Number.isFinite(Number(photo.likeCount))) ? Number(photo.likeCount) : 0;
      likes.textContent = `‚ù§Ô∏è ${likeCount} likes`;
      const imageCount = document.createElement('span');
      const imgCount = Array.isArray(images) ? images.length : 0;
      imageCount.textContent = `üñºÔ∏è ${imgCount} image${imgCount === 1 ? '' : 's'}`;
      const date = document.createElement('span');
      date.textContent = createdAtLabel || '';
      stats.appendChild(likes);
      stats.appendChild(imageCount);
      stats.appendChild(date);
      info.appendChild(stats);

      item.appendChild(info);

      const actions = document.createElement('div');
      actions.className = 'photo-actions';

      const editBtn = document.createElement('button');
      editBtn.className = 'btn-edit';
      editBtn.type = 'button';
      editBtn.textContent = 'Edit';
      editBtn.addEventListener('click', () => editPhoto(docId));

      const delBtn = document.createElement('button');
      delBtn.className = 'btn-delete';
      delBtn.type = 'button';
      delBtn.textContent = 'Delete';
      delBtn.addEventListener('click', () => deletePhoto(docId));

      actions.appendChild(editBtn);
      actions.appendChild(delBtn);
      item.appendChild(actions);

      return item;
    }

    function showMessage(id, text) {
      const el = document.getElementById(id);
      if (!el) return;
      el.textContent = text;
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 4000);
    }

    function logout() {
      auth.signOut().then(() => {
        window.location.href = 'dashboard.html';
      });
    }

    auth.onAuthStateChanged(async (user) => {
      if (!user || user.uid !== ADMIN_UID) {
        window.location.href = 'dashboard.html';
        return;
      }
      setupEventListeners();
      loadPhotos();
    });

    function setupEventListeners() {
      const uploadArea = document.getElementById('uploadArea');
      const fileInput = document.getElementById('fileInput');
      const uploadForm = document.getElementById('uploadForm');
      const backBtn = document.getElementById('backBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      const clearBtn = document.getElementById('clearBtn');
      const replaceCheckbox = document.getElementById('replaceImagesCheckbox');

      if (backBtn) {
        backBtn.addEventListener('click', () => {
          window.location.href = 'dashboard.html';
        });
      }

      if (logoutBtn) {
        logoutBtn.addEventListener('click', logout);
      }

      if (clearBtn) {
        clearBtn.addEventListener('click', resetForm);
      }

      if (uploadArea) {
        uploadArea.addEventListener('click', () => fileInput && fileInput.click());
        uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('active'); });
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('active'));
        uploadArea.addEventListener('drop', (e) => {
          e.preventDefault();
          uploadArea.classList.remove('active');
          handleFileDrop(e.dataTransfer.files);
        });
      }

      if (fileInput) {
        fileInput.addEventListener('change', (e) => handleFileDrop(e.target.files));
      }

      if (replaceCheckbox) {
        replaceCheckbox.addEventListener('change', (e) => {
          replaceImages = !!(e && e.target && e.target.checked);
          // When switching modes, re-check how many new files can be selected.
          reconcileSelectionLimit();
          renderExistingImages();
          renderSelectedImagesPreview();
          updateFileInfoText();
        });
      }

      if (uploadForm) {
        uploadForm.addEventListener('submit', handleUpload);
      }
    }

    function handleFileDrop(files) {
      if (!files || files.length === 0) return;
      const incoming = Array.from(files).filter(Boolean);
      if (incoming.length === 0) return;

      const keptExistingCount = editingPhotoId ? getKeptExistingUrls().length : 0;
      const allowedTotalNew = editingPhotoId ? (replaceImages ? 10 : Math.max(0, 10 - keptExistingCount)) : 10;
      if (editingPhotoId && !replaceImages && allowedTotalNew <= 0) {
        showMessage('errorMessage', '‚ùå This project already has 10 images. Remove one to add another.');
        return;
      }

      const currentSelected = Array.isArray(selectedFiles) ? selectedFiles.filter(Boolean).length : 0;
      const remaining = Math.max(0, allowedTotalNew - currentSelected);
      if (remaining <= 0) {
        showMessage('errorMessage', '‚ùå No remaining slots for new images. Remove one or enable Replace mode.');
        return;
      }

      if (incoming.length > remaining) {
        showMessage('errorMessage', `‚ùå Max 10 images per project. Only the first ${remaining} were selected.`);
      }

      const nextFiles = incoming.slice(0, remaining);
      for (const f of nextFiles) {
        if (f && f.size > 50 * 1024 * 1024) {
          showMessage('errorMessage', `‚ùå "${f.name}" is too large. Max 50MB per image.`);
          return;
        }
      }

      selectedFiles = mergeSelectedFiles(selectedFiles, nextFiles, allowedTotalNew);
      updateFileInfoText();
      renderSelectedImagesPreview();
    }

    async function uploadSelectedFiles(photoId, files) {
      const finalFiles = Array.isArray(files) ? files.filter(Boolean).slice(0, 10) : [];
      const fullUrls = [];
      const thumbUrls = [];

      for (let i = 0; i < finalFiles.length; i++) {
        const file = finalFiles[i];

        let uploadFile = file;
        let uploadThumbFile = null;
        try {
          uploadFile = await optimizeImageForUpload(file);
          uploadThumbFile = await optimizeThumbnailForUpload(file);
        } catch (e) {
          const msg = String(e && e.message ? e.message : e);
          if (msg === 'raw-not-supported') {
            throw new Error(`"${file && file.name ? file.name : 'This file'}" can't be uploaded (RAW files are not supported). Export it as JPG/WebP first.`);
          }
          if (msg === 'file-too-large') {
            throw new Error(`"${file && file.name ? file.name : 'This file'}" is still too large after optimization. Please export a smaller image.`);
          }
          if (msg === 'heic-convert-unavailable') {
            throw new Error(`Can't optimize HEIC on this browser right now. Try converting to JPG first or use Chrome.`);
          }
          // Fallback to original file, but keep a safety cap.
          if (file && file.size > 1.5 * 1024 * 1024) {
            throw new Error(`"${file && file.name ? file.name : 'This file'}" is too large. Please choose a smaller image.`);
          }
          uploadFile = file;
          uploadThumbFile = file;
        }

        const stamp = `${Date.now()}_${i}`;
        const safeFullName = (uploadFile && uploadFile.name)
          ? String(uploadFile.name).replace(/[^a-zA-Z0-9._-]+/g, '_')
          : `image_${i}.jpg`;
        const safeThumbName = (uploadThumbFile && uploadThumbFile.name)
          ? String(uploadThumbFile.name).replace(/[^a-zA-Z0-9._-]+/g, '_')
          : `image_${i}_thumb.jpg`;

        const fullPath = `portfolio/${photoId}/${stamp}_full_${safeFullName}`;
        const thumbPath = `portfolio/${photoId}/${stamp}_thumb_${safeThumbName}`;

        const commonMeta = { cacheControl: 'public, max-age=31536000, immutable' };
        const fullMeta = {
          ...commonMeta,
          ...(uploadFile && uploadFile.type ? { contentType: uploadFile.type } : {})
        };
        const thumbMeta = {
          ...commonMeta,
          ...(uploadThumbFile && uploadThumbFile.type ? { contentType: uploadThumbFile.type } : {})
        };

        const fullRef = storage.ref(fullPath);
        await fullRef.put(uploadFile, fullMeta);
        fullUrls.push(await fullRef.getDownloadURL());

        const thumbRef = storage.ref(thumbPath);
        await thumbRef.put(uploadThumbFile || uploadFile, thumbMeta);
        thumbUrls.push(await thumbRef.getDownloadURL());
      }

      return { fullUrls, thumbUrls };
    }

    async function deleteStorageUrls(urls) {
      const list = Array.isArray(urls) ? urls.filter(Boolean) : [];
      for (const url of list) {
        try {
          const ref = storage.refFromURL(url);
          await ref.delete();
        } catch {
          // ignore (local/static URLs or already deleted)
        }
      }
    }

    async function handleUpload(e) {
      e.preventDefault();
      const titleEl = document.getElementById('photoTitle');
      const catEl = document.getElementById('photoCategory');
      if (!titleEl || !titleEl.value) {
        showMessage('errorMessage', '‚ùå Please enter a photo title.');
        return;
      }
      if (!catEl || !catEl.value) {
        showMessage('errorMessage', '‚ùå Please select a category.');
        return;
      }
      const submitBtn = document.getElementById('submitBtn');
      if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<span class="loading"></span> Uploading...';
      }
      try {
        const user = auth.currentUser;
        if (!user || user.uid !== ADMIN_UID) {
          showMessage('errorMessage', '‚ùå You are not authorized to upload photos.');
          return;
        }
        const title = titleEl.value;
        const description = document.getElementById('photoDescription').value;
        const category = catEl.value;
        if (editingPhotoId) {
          const updateData = { title, description, category };

          const needsImageUpdate =
            (Array.isArray(selectedFiles) && selectedFiles.length > 0) ||
            (removedImageUrls && removedImageUrls.size > 0) ||
            replaceImages === true;

          if (needsImageUpdate) {
            const docSnap = await db.collection('portfolio').doc(editingPhotoId).get();
            const prev = docSnap.exists ? (docSnap.data() || {}) : {};
            const prevUrls = getPrevUrlsFromDoc(prev);
            const prevThumbs = alignThumbsToFull(prevUrls, getPrevThumbUrlsFromDoc(prev));
            const fullToThumb = mapFullToThumb(prevUrls, prevThumbs);

            if (replaceImages && (!selectedFiles || selectedFiles.length === 0)) {
              showMessage('errorMessage', '‚ùå Select at least one image to replace the existing images.');
              return;
            }

            const kept = replaceImages
              ? []
              : prevUrls.filter((u) => u && !removedImageUrls.has(normalizeHttpUrl(u) || u)).slice(0, 10);
            const keptThumbs = kept.map((u) => fullToThumb.get(u) || u).slice(0, 10);

            const allowedNew = replaceImages ? 10 : Math.max(0, 10 - kept.length);
            const filesToUpload = Array.isArray(selectedFiles)
              ? selectedFiles.filter(Boolean).slice(0, allowedNew)
              : [];

            let newUrls = [];
            let newThumbs = [];
            if (filesToUpload.length) {
              const uploaded = await uploadSelectedFiles(editingPhotoId, filesToUpload);
              newUrls = (uploaded && Array.isArray(uploaded.fullUrls)) ? uploaded.fullUrls : [];
              newThumbs = (uploaded && Array.isArray(uploaded.thumbUrls)) ? uploaded.thumbUrls : [];
            }

            const combined = kept.concat(newUrls).slice(0, 10);
            const combinedThumbs = alignThumbsToFull(combined, keptThumbs.concat(newThumbs).slice(0, 10));
            updateData.imageUrls = combined;
            updateData.thumbUrls = combinedThumbs;
            updateData.imageUrl = combined[0] || null;
            updateData.thumbUrl = combinedThumbs[0] || combined[0] || null;

            const removedFull = replaceImages
              ? prevUrls
              : prevUrls.filter((u) => removedImageUrls.has(normalizeHttpUrl(u) || u));
            const removedThumb = replaceImages
              ? prevThumbs
              : removedFull.map((u) => fullToThumb.get(u) || u);
            const toDelete = Array.from(new Set([...(removedFull || []), ...(removedThumb || [])].filter(Boolean)));
            if (toDelete.length) deleteStorageUrls(toDelete).catch(() => {});
          }

          await db.collection('portfolio').doc(editingPhotoId).update(updateData);
          showMessage('successMessage', '‚úì Photo updated successfully!');
          // Keep edit mode open; refresh Current Images strip.
          selectedFiles = [];
          clearSelectedPreviewObjectUrls();
          const selWrap = document.getElementById('selectedImagesPreview');
          if (selWrap) {
            clearElement(selWrap);
            selWrap.style.display = 'none';
          }
          const fileInput = document.getElementById('fileInput');
          if (fileInput) fileInput.value = '';
          updateFileInfoText();

          try {
            const refreshed = await db.collection('portfolio').doc(editingPhotoId).get();
            if (refreshed.exists) {
              const data = refreshed.data() || {};
              existingImageUrls = getPrevUrlsFromDoc(data);
              existingThumbUrls = alignThumbsToFull(existingImageUrls, getPrevThumbUrlsFromDoc(data));
            }
          } catch (e) {
            console.warn('Could not refresh portfolio item after save', e);
          }

          removedImageUrls = new Set();
          replaceImages = false;
          const checkbox = document.getElementById('replaceImagesCheckbox');
          if (checkbox) checkbox.checked = false;
          renderExistingImages();
          loadPhotos();
          return;
        }
        if (!selectedFiles || selectedFiles.length === 0) {
          showMessage('errorMessage', '‚ùå Please select at least one image first.');
          return;
        }

        // New post: hard enforce the 10-image limit at submit time as well.
        // (Selection should already enforce this, but this prevents edge cases.)
        const safeSelected = Array.isArray(selectedFiles) ? selectedFiles.filter(Boolean) : [];
        if (safeSelected.length > 10) {
          selectedFiles = safeSelected.slice(0, 10);
          renderSelectedImagesPreview();
          updateFileInfoText();
          showMessage('errorMessage', '‚ùå Max 10 images per post. Extra selections were removed.');
          return;
        }

        const photoId = 'photo-' + Date.now();
        const uploaded = await uploadSelectedFiles(photoId, selectedFiles);
        const imageUrls = (uploaded && Array.isArray(uploaded.fullUrls)) ? uploaded.fullUrls : [];
        const thumbUrls = (uploaded && Array.isArray(uploaded.thumbUrls)) ? uploaded.thumbUrls : [];
        const imageUrl = imageUrls[0] || null;
        const thumbUrl = thumbUrls[0] || imageUrl;
        await db.collection('portfolio').doc(photoId).set({
          id: photoId,
          title,
          description,
          category,
          imageUrl,
          imageUrls,
          thumbUrl,
          thumbUrls: alignThumbsToFull(imageUrls, thumbUrls),
          likeCount: 0,
          createdAt: new Date(),
          uploadedBy: 'admin'
        });
        showMessage('successMessage', '‚úì Photo uploaded successfully!');
        resetForm();
        loadPhotos();
      } catch (err) {
        console.error('Upload error:', err);
        const errCode = (err && typeof err.code === 'string') ? err.code : '';
        const errMsg = (err && typeof err.message === 'string') ? err.message : '';
        const msgLower = errMsg.toLowerCase();
        const isAccessControl = msgLower.includes('access control checks');
        const isCors = /\bcors\b|preflight/i.test(errMsg);
        const isStorage = (errCode && errCode.startsWith('storage/')) || /firebasestorage\.googleapis\.com|storage\.googleapis\.com/i.test(errMsg);

        if (err.code === 'permission-denied') {
          showMessage('errorMessage', '‚ùå You are not allowed to modify portfolio items.');
        } else if (isAccessControl) {
          // This is almost always API key HTTP referrer restrictions (GCP) blocking localhost.
          showMessage(
            'errorMessage',
            `‚ùå Upload failed${errCode ? ' (' + errCode + ')' : ''}. Your browser blocked a Firebase request due to access control checks. This is usually your Google Cloud API key referrer restrictions. Allow these referrers: http://localhost:5500/* and http://127.0.0.1:5500/* (plus https://itwasdom.github.io/*). Also add localhost + 127.0.0.1 to Firebase Auth Authorized domains. ${errMsg ? 'Details: ' + errMsg : ''}`
          );
        } else if (errCode === 'storage/unauthorized') {
          showMessage(
            'errorMessage',
            `‚ùå Upload failed (storage/unauthorized). This is almost always Firebase Storage Rules blocking writes for your user. Update Firebase Console ‚Üí Storage ‚Üí Rules to allow write for the admin UID (${ADMIN_UID}) under the /portfolio/ path. ${errMsg ? 'Details: ' + errMsg : ''}`
          );
        } else if (
          isStorage || isCors
        ) {
          showMessage(
            'errorMessage',
            `‚ùå Upload failed${errCode ? ' (' + errCode + ')' : ''}. If you are running locally, this is often Firebase Storage CORS or blocked API key referrers. Check STORAGE_CORS_SETUP.md and make sure your API key allowlist includes http://localhost:5500/* and http://127.0.0.1:5500/* and that Firebase Auth Authorized domains include localhost/127.0.0.1. ${errMsg ? 'Details: ' + errMsg : ''}`
          );
        } else {
          showMessage('errorMessage', '‚ùå Error uploading photo: ' + (err.message || 'Please try again.'));
        }
      } finally {
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.innerHTML = '<i class="fas fa-upload"></i> Upload Photo';
        }
      }
    }

    function resetForm() {
      const form = document.getElementById('uploadForm');
      const fileInput = document.getElementById('fileInput');
      const info = document.getElementById('fileInfo');
      const submitBtn = document.getElementById('submitBtn');
      if (form) form.reset();
      if (fileInput) fileInput.value = '';
      if (info) info.textContent = '';
      if (submitBtn) submitBtn.innerHTML = '<i class="fas fa-upload"></i> Upload Photo';
      selectedFiles = [];
      clearSelectedPreviewObjectUrls();
      const selWrap = document.getElementById('selectedImagesPreview');
      if (selWrap) {
        clearElement(selWrap);
        selWrap.style.display = 'none';
      }
      editingPhotoId = null;
      existingImageUrls = [];
      removedImageUrls = new Set();
      replaceImages = false;
      const section = document.getElementById('existingImagesSection');
      if (section) section.style.display = 'none';
      const checkbox = document.getElementById('replaceImagesCheckbox');
      if (checkbox) checkbox.checked = false;
    }

    async function loadPhotos() {
      try {
        const snapshot = await db.collection('portfolio').orderBy('createdAt', 'desc').get();
        const photoList = document.getElementById('photoList');
        const photoCount = document.getElementById('photoCount');

        const visible = [];
        snapshot.forEach((doc) => visible.push({ id: doc.id, data: doc.data() }));

        if (visible.length === 0) {
          renderEmptyState(photoList);
          if (photoCount) photoCount.textContent = '0';
          return;
        }

        if (photoCount) photoCount.textContent = String(visible.length);
        clearElement(photoList);
        visible.forEach((row) => {
          const docId = row.id;
          const photo = row.data;
          let createdAtLabel = '';
          try {
            if (photo.createdAt && typeof photo.createdAt.toDate === 'function') {
              createdAtLabel = new Date(photo.createdAt.toDate()).toLocaleDateString();
            } else if (photo.createdAt instanceof Date) {
              createdAtLabel = photo.createdAt.toLocaleDateString();
            }
          } catch (e) {
            console.warn('Bad createdAt field for doc', docId, e);
            createdAtLabel = '';
          }
          const item = createPhotoItem(docId, photo, createdAtLabel);
          if (photoList) photoList.appendChild(item);
        });
      } catch (err) {
        console.error('Error loading photos:', err);
      }
    }

    async function deletePhoto(photoId) {
      if (!confirm('üóëÔ∏è Delete this photo? This cannot be undone.')) return;
      try {
        const user = auth.currentUser;
        if (!user || user.uid !== ADMIN_UID) {
          showMessage('errorMessage', '‚ùå You are not authorized to delete photos.');
          return;
        }
        const docSnap = await db.collection('portfolio').doc(photoId).get();
        if (docSnap.exists) {
          const data = docSnap.data() || {};
          const urls = Array.isArray(data.imageUrls)
            ? data.imageUrls
            : (data.imageUrl ? [data.imageUrl] : []);
          const thumbUrls = Array.isArray(data.thumbUrls)
            ? data.thumbUrls
            : (data.thumbUrl ? [data.thumbUrl] : []);
          await deleteStorageUrls([...(urls || []), ...(thumbUrls || [])]);
        }
        await db.collection('portfolio').doc(photoId).delete();
        showMessage('successMessage', '‚úì Photo deleted successfully!');
        loadPhotos();
      } catch (err) {
        console.error('Delete error:', err);
        if (err.code === 'permission-denied') {
          showMessage('errorMessage', '‚ùå You are not allowed to modify portfolio items.');
        } else {
          showMessage('errorMessage', '‚ùå Error deleting photo: ' + (err.message || 'Please try again.'));
        }
      }
    }

    async function editPhoto(photoId) {
      try {
        const user = auth.currentUser;
        if (!user || user.uid !== ADMIN_UID) {
          showMessage('errorMessage', '‚ùå You are not authorized to edit photos.');
          return;
        }
        const docSnap = await db.collection('portfolio').doc(photoId).get();
        if (!docSnap.exists) {
          showMessage('errorMessage', '‚ùå Photo not found.');
          return;
        }
        const photo = docSnap.data();
        editingPhotoId = photoId;
        existingImageUrls = getPrevUrlsFromDoc(photo);
        existingThumbUrls = alignThumbsToFull(existingImageUrls, getPrevThumbUrlsFromDoc(photo));
        removedImageUrls = new Set();
        replaceImages = false;
        const titleInput = document.getElementById('photoTitle');
        const descInput = document.getElementById('photoDescription');
        const categorySelect = document.getElementById('photoCategory');
        const submitBtn = document.getElementById('submitBtn');
        if (titleInput) titleInput.value = photo.title || '';
        if (descInput) descInput.value = photo.description || '';
        if (categorySelect) categorySelect.value = photo.category || '';
        if (submitBtn) submitBtn.innerHTML = '<i class="fas fa-save"></i> Save Changes';

        // Clear any pending new selection when switching items.
        selectedFiles = [];
        clearSelectedPreviewObjectUrls();
        const selWrap = document.getElementById('selectedImagesPreview');
        if (selWrap) {
          clearElement(selWrap);
          selWrap.style.display = 'none';
        }
        const fileInput = document.getElementById('fileInput');
        if (fileInput) fileInput.value = '';
        const info = document.getElementById('fileInfo');
        if (info) info.textContent = '';

        renderExistingImages();
        const container = document.querySelector('.upload-area');
        if (container) container.scrollIntoView({ behavior: 'smooth', block: 'start' });
      } catch (err) {
        console.error('Edit error:', err);
        showMessage('errorMessage', '‚ùå Error loading photo for edit: ' + (err.message || 'Please try again.'));
      }
    }
  </script>
</body>
</html>
